# 二分查找

[**有序、顺序表/字符串**] 上的查找 一般考察二分查找.

#### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

使用双闭区间，有序数组[(0)a,(1) b,(2) c,(3) d]，要查找的元素target，查找失败必分以下情况：

* b < target < c，则跳出`while`时必有 `r = 2`，`l = 3`，要插入的位置即为`r+1`或`l-1`
* target < a，则跳出`while`时必有 `r = -1`，要插入的位置即为`r+1`
* target > d，则跳出`while`时必有`r = 3`，`l = 4`，要插入的位置即为`r+1`

因此，查找失败，要插入的位置必然为`r+1`

#### [475. 供暖器](https://leetcode-cn.com/problems/heaters/comments/)

**思路 1. 排序 + 二分查找答案**

考虑二分查找答案，最小为 l = 0，最大不超过 r = max(max_houses, max_heaters).

1. 首先将houses和heaters从小到大排序;
2. 取 mid = l + (r-l)/2, h = 0, k = 0, 其中 mid 表示待判断是否可行的半径，h表示当前house，k表示当前heater;
3. 判断:
   * 若当前house处于当前header的覆盖范围内，即 heaters[k] - mid <= houses[h] <= heaters[k] + mid，则判断下一个houses，++h;
   * 若当前house太靠左，当前heater覆盖在当前半径mid下覆盖不到，即houses[h] < heaters[k] - mid，则需要更大的半径，l = mid + 1 (左边的heater都覆盖不到，右边的更别想了);
   * 若当前house太靠右，当前heater覆盖在当前半径mid下覆盖不到，即houses[h] > heaters[k] + mid，则尝试下一个heater，++k, 若已经是最后一个heater，则需要更大的半径，l = mid + 1.
4. 当前半径下若能全覆盖，则尝试更小的半径，r = mid

这里while(l < r), 缩小半径时 r = mid 而非 r = mid-1, 则最终r就是满足条件的最小半径.

```C++
int findRadius(vector<int>& houses, vector<int>& heaters) {
    sort(houses.begin(), houses.end());
    sort(heaters.begin(), heaters.end());
    int l = 0, r = max(houses.back(), heaters.back());
    while(l < r) {
        int mid = l + (r-l)/2;
        int h = 0, k = 0;
        while(h < houses.size()) {
            if(houses[h] >= heaters[k] - mid && houses[h] <= heaters[k] + mid) {
                ++h;
            } else if(houses[h] < heaters[k] - mid) {
                l = mid + 1;
                break;
            } else {
                ++k;
                if(k >= heaters.size()) {
                    l = mid + 1;
                    break;
                }
            }
        }
        if(h == houses.size())
            r = mid;
    }
    return r;
}
```

m 是数组houses 的长度，n 是数组heaters 的长度

时间复杂度： O(nlogn + mlogm + (n+m)logmax(max_houses, max_heaters))

空间复杂度： O(1)

![image](https://user-images.githubusercontent.com/49873642/146747023-15926673-7c4e-464b-ac18-5fa2be69e63e.png)

嗯... 不大行

**思路 2.** 

1. 对于每个房屋，要么用前面第一个暖气，要么用后面第一个暖气，二者取近的，得到距离；
2. 对于所有的房屋，选择最大的上述距离.

 **排序 + 二分查找heater**

二分查找每个house左边第一个供暖器k(heater <= house), 则k+1就为其右边第一个供暖器; 

1. 求每个房屋据左右最近两个供暖器的最近距离;
2. 求以上所有最近距离的最大值。

```C++
int findRadius(vector<int>& houses, vector<int>& heaters) {
    sort(heaters.begin(), heaters.end());
    int minRadius = 0;
    for(int house : houses) {
        if(house <= heaters[0]) {  // 可能最左边的供暖器也在其右边
            minRadius = max(minRadius, heaters[0] - house);
            continue;
        }
        int l = 0, r = heaters.size() - 1, mid, left;
        while(l <= r) {
            mid = l + (r-l)/2;
            if(heaters[mid] > house) r = mid - 1;
            else  {
                left = mid;
                l = mid + 1;
            }
        }
        if(left == heaters.size() - 1)
            minRadius = max(minRadius, house - heaters[left]);
        else   
            minRadius = max(minRadius, min(heaters[left+1] - house, house - heaters[left]));
    }
    return minRadius;
}
```

时间复杂度： O(nlogn + mlogn) = O((n+m)logn)

空间复杂度： O(1)

**双指针**

若houses和heaters都有序，若第h个house左边第一个供暖器为k，则第h+1个必 >= k.

因此k指针不会后退，又h指针不会后退，所以只需一次遍历.

```C++
int findRadius(vector<int>& houses, vector<int>& heaters) {
    sort(heaters.begin(), heaters.end());
    sort(houses.begin(), houses.end());
    int minRadius = 0;
    int h = 0, k = 0;
    while(h < houses.size() && houses[h] <= heaters[0]) { // 先算在第一个供暖器左边的房子
        minRadius = max(minRadius, heaters[0] - houses[h]);
        ++h;
    }
    while(h < houses.size() ){
        while(k < heaters.size() - 1 && heaters[k+1] <= houses[h]) ++k;
        if(k == heaters.size() - 1) 
            minRadius = max(minRadius, houses[h] - heaters[k]);
        else
            minRadius = max(minRadius, min(heaters[k+1] - houses[h], houses[h] - heaters[k]));
        ++h;
    }
    return minRadius;
}
```

时间复杂度： O(nlogn + mlogn + m + n) 

空间复杂度： O(1)

时间主要花在排序上，若本就有序，则下降到线性时间复杂度。

#### [686. 重复叠加字符串匹配](https://leetcode-cn.com/problems/repeated-string-match/comments/) （hard 字节二面出现过)

首先明确，若b长度不为0，则a至少重复1次，最多重复 int( len(b) / len(a) ) + 2 次. 

最多: b的开头结尾各用a的部分，中间最多包含 int( len(b) / len(a) )个a.

使用**二分查找答案** + 字符串匹配.

```C++
int repeatedStringMatch(string a, string b) {
    if(b.size() == 0) return 0;
    int l = 1, r = b.size() / a.size() + 2 + 1;  // 最多 ~ +2次, 额外 +1 为了方便判断是否有解
    while(l < r) {                              // O(logN)
        int mid = l + (r-l)/2;
        string t;
        for(int i=1; i<=mid; ++i) t += a;       // 最坏线性
        if(t.find(b) != string::npos) r = mid;  // 暴力匹配, O(MN)
        else l = mid+1;
    }
    return r == b.size() / a.size() + 2 + 1 ? -1 : r;
}
```

#### [1044. 最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)

第一想法：两层for，枚举可能出现的所有字串，即可获得最长重复子串。 时间复杂度O(n^2)，对于 n = 3e4，必然超时.

第二想法：重复子串最长1，最短n-1，二分查找答案。具体做法：

```C++
查找所有长度为mid = l + (r-l)/2 的子串，
若某个子串出现次数>2，则存在长度为mid的重复子串，接下来尝试寻找更长的，l = mid + 1;
否则，r = mid - 1.

实现代码:
string longestDupSubstring(string s) {
    int n = s.size();
    int l = 1, r = n - 1, mid;
    string result = "";
    while(l <= r) {
        set<string> uset;
        mid = l + (r-l)/2;
        for(int i = 0; i < n - mid + 1; ++i) {
            string t = s.substr(i, mid);
            if(uset.count(t)) {
                result = t;
                l = mid + 1;
                break;
            } 
            else uset.insert(t);
        }
        if(result.size() != mid) 
            r = mid-1;
    }
    return result;
}
二分: O(logn)
取子串次数: n - mid;  O(n)
取子串: substr()  O(mid);
判断是否出现: unordered_set / set O(1);

时间复杂度: < O(n^2logn)  
这里mid统一按照n计算，实际上平均远达不到给出的时间复杂度，但还是会超时
```

取子串因为要执行字符拷贝操作，因此时间开销总是线性。若将此操作时间优化到常数级别，则算法整体时间复杂度下降到O(nlogn). 

解决方法： 字符串编码. 

只有小写字母，即最多26个不同字符，因此可以用 0 - 25 的26进制数来表示 a - z 26个字符.

比如对于字符串"abcdef"中的子串"abc"， 我们可以表示为 `encode = 0 * 26^2 + 1 * 26^1 + 2 * 26^0`， 当取下一个子串"bcd"时，只需要计算`(encode - 0 * 26^2) * 26 +  3 * 26^0)`;

经过上述编码，取子串操作(原代码中为substr()语句)时间复杂度下降到O(1)，算法整体复杂度为O(nlogn).

但仍存在一个问题，encode可能越界，取模可能发生“碰撞”，即不同encode mod 结果相同.  当然可以使用多个mod(多个编码，相同mod P)，但这总归是个概率问题，严格说不是确定性算法.

**二分查找答案 + 判断：滑动窗口 + 字符串编码 + 双哈希**

```C++
class Solution {
public:
    long long mod = 1000000006;
    long long fastPow(long long x, int y) {  // 快速幂
        long long  result = 1;
        while(y > 0) {
            if(y & 1) result = (result * x) % mod;
            x = (x * x) % mod;
            y >>= 1;
        }
        return result;
    } 
    string longestDupSubstring(string s) {
        int n = s.size();
        int l = 1, r = n - 1, mid;
        string result = "";
        int m1 = 26, m2 = 27;

        while(l <= r) {
            mid = l + (r-l)/2;
            unordered_set<long long> s1, s2;
            long long encode1 = 0, encode2 = 0;
            for(int i=0; i<mid; ++i) {
                encode1 = (encode1 + int(s[i]-'a') * fastPow(m1, mid-i-1)) % mod;
                encode2 = (encode2 + int(s[i]-'a') * fastPow(m2, mid-i-1)) % mod;
            }
            s1.insert(encode1);
            s2.insert(encode2);
            long long mm1 = fastPow(m1, mid-1), mm2 = fastPow(m2, mid-1);
            for(int i=1; i<n-mid+1; ++i) {
                encode1 -= (int(s[i-1] - 'a') * mm1) % mod;
                if(encode1 < 0) encode1 += mod;    // *************
                encode1 = (encode1 * m1) % mod;
                encode1 += int(s[i+mid-1] - 'a');
                encode2 -= (int(s[i-1] - 'a') * mm2) % mod;
                if(encode2 < 0) encode2 += mod;    // *************
                encode2 = (encode2 * m2) % mod;
                encode2 += int(s[i+mid-1] - 'a');
                if(s1.find(encode1) != s1.end() && s2.find(encode2) != s2.end()) {
                    result = s.substr(i, mid);
                    l = mid+1;
                    break;   
                }
                s1.insert(encode1);
                s2.insert(encode2);
            }
            if(result.size() != mid)
                r = mid-1;
        }
        return result;
    }
};
```

需要注意的两个点:

1. n可能很大，需要使用快速幂，且求幂的过程中就需要mod
2. 滑动窗口，首位移出做减法后，encode可能会变成负数，这种情况下需要 + mod的值.

这题确定性解法是**后缀数组**， 哎， 下次一定.



