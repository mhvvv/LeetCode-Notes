#### 单调栈的一般应用场景

一维数组，寻找数组中任一元素左边或右边第一个比自己大/小的元素的位置.

#### 算法逻辑

先来看这道题 [LeetCode - 739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

我们要寻找每个元素后面第一个比它大的元素的位置，最简单的想法是两层for，时间复杂度O(n).

下面看单调栈解法:

单调栈，就是维护一个从栈头到栈尾元素值递增的栈，需要特别注意，**栈中一般并不存元素的值，而是存元素的下标**，当需要访问元素值时，可以方便的用下标nums[i]访问.

从前到后枚举数组中的每一个元素，将其下标入栈：
1. 若当前元素 < 栈顶元素，直接入栈. 
2. 若当前元素 = 栈顶元素，直接入栈. 
3. 若当前元素 > 栈顶元素，则为了维护单调的性质，需不断弹出栈顶元素，直到栈为空或栈顶元素比其大，将其入栈.  

情况1.2.说明当前元素前方所有元素都比其大，即前方所有元素都未遇到比自身大的元素;

情况3. 说明被弹出的元素遇到了第一个比本身大的元素，即当前枚举的元素. (单调性质的作用: 元素一旦遇到后方第一个比其大的元素，就一定会被弹出栈)

算法时间复杂度: O(n), 空间复杂度O(n). 经典的空间换时间.

这题的实现代码，即为单调栈的代码模板:

```C++
vector<int> dailyTemperatures(vector<int>& temperatures) {
    vector<int> result(temperatures.size(), 0);
    stack<int> st;
    for(int i=0; i<temperatures.size(); ++i) {
        while(!st.empty() && temperatures[i] > temperatures[st.top()]) {
            result[st.top()] = i - st.top();
            st.pop();
        }
        st.push(i);
    }
    return result;
}
```

### 题目

[LeetCode - 496. 下一个更大元素I](https://leetcode-cn.com/problems/next-greater-element-i/)

此题需要解决两个问题:
1. 对于nums1中的每一个数字，如何在nums2中找到对应的数字？

    ✅ 哈希表，时间复杂度O(m) + O(n). (查表 + 建表) 
   
    C++实现时，应使用 unordered_map 而非 map, 否则时间复杂度上升到O(n + mlogn).   

2. 对于nums2中的每一个数字，如何找到其下一个更大的数字 ？

    ✅ 单调栈，时间复杂度O(n).

1中建表操作可以在解决2时顺便解决，时间复杂度O(n + m).

```C++
vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
    unordered_map<int, int> ump;    // <value, Index>
    vector<int> bigger(nums2.size(), -1);
    stack<int> st;
    for(int i=0; i<nums2.size(); ++i) {
        ump[nums2[i]] = i;
        while(!st.empty() && nums2[i] > nums2[st.top()]) {
            bigger[st.top()] = i;
            st.pop();
        }
        st.push(i);
    }

    vector<int> result(nums1.size());    // 一次给足空间
    for(int i=0; i<nums1.size(); ++i)
        result[i] = bigger[ump[nums1[i]]] == -1 ? -1 : nums2[bigger[ump[nums1[i]]]];
    return result;

}
```
---

[LeetCode - 503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

更简单的想法：两个数组拼接一起

更简单的实现：若从下标i出发“转一圈”回到下标i-1还没有找到更大的，则没有更大的。当第二次遍历到数组尾时，对每个元素的判断都已“转了一圈”。

时间复杂度：O(2n)

```C++
vector<int> nextGreaterElements(vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n, -1);
    stack<int> st; 
    for(int i=0; i<n * 2; ++i) {
        while(!st.empty() && nums[i % n] > nums[st.top()]) {
            result[st.top()] = nums[i % n];
            st.pop(); 
        }
        st.push(i % n);
    }
    return result;
}
```
---
[84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

计算以每个柱子的高为高的矩形的面积，得出最大值.

问题是如何求宽：对柱子i来说，只要求出i右边第一个比i矮的柱子的下标right以及左边第一个比i矮的柱子的下标left，则对以height[i]为高的矩形来说，宽度即为`right - left - 1`

上述求宽可以用单调栈实现，时间复杂度O(n)

```C++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        vector<int> left(n), right(n);
        stack<int> st;
        for(int i = 0; i < n; ++i) {
            while(!st.empty() && heights[st.top()] > heights[i]) {
                right[st.top()] = i;
                st.pop();
            }
            st.push(i);
        }
        while(!st.empty()) {
            right[st.top()] = n;
            st.pop();
        }
        for(int i=n-1; i >= 0; --i) {
            while(!st.empty() && heights[st.top()] > heights[i]) {
                left[st.top()] = i;
                st.pop();
            }
            st.push(i);
        }
        while(!st.empty()) {
            left[st.top()] = -1;
            st.pop();
        }
        int result = 0;
        for(int i = 0; i < n; ++i) 
            result = max(result, (right[i] - left[i] - 1) * heights[i]);
        return result;
    }
};
```

时间复杂度O(n), 空间复杂度O(n)
