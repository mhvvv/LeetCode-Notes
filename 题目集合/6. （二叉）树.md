**所有的题都尝试递归dfs和非递归bfs层次遍历两种方法**

**是否要有返回值，却决于是否需要返回值，一般来说，遍历整棵树不需要返回值，否则需要**

### 简单遍历

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

#### [559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

#### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)    不用记忆化，不会重复计算某个节点的高度（一次遍历）

#### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

#### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

#### [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)     如何使用递归解法

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

#### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

#### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)





### 不正常的遍历

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)





### 建立二叉树

> 本质就是不断利用前/后续遍历序列建立根节点，  中序只是用来判断是否还要继续建立

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)      难点在于如何确定子树节点在

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)





### 完全二叉树的性质

设根节点为第0层，
则:
第 h 层最多有 $2^{h}$个结点；
第h层的节点号为 [$2^{h} , 2^{h+1}-1$];    （根节点为1号， 从左到右从根到叶递增)
前h 层最多有 $2^{h+1}-1 $个结点；



[222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)  

位运算 + **二分查找可能的答案 → 验证**

![](https://secure2.wostatic.cn/static/msTexFDWEd48x9npn4skYh/image.png)

如图，根据上述编号性质， 第k个节点的二进制编号 代表了他在树中的位置， 

1: 1
2: 10   L    
3: 11   R
4: 100  LL
5: 101  LR
6: 110   RL





### 二叉搜索树

二叉搜索树的中序遍历序列为升序序列；

验证二叉搜索树， 除了利用中序遍历序列为升序序列外，还可以直接利用二叉搜索树的定义，

二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数;
- 节点的右子树只包含 **大于** 当前节点的数;
- 所有左子树和右子树自身必须也是二叉搜索树。

最容易想到的代码为：

```C++
bool isBST(TreeNode *root) {
    if(root == nullptr) return true;
    
    if(isBST(root->left) && isBST(root->right) && root->val > getMax(root->left) && root->val < getMin(root->right)) 
        return true;
    return false;
}
```

然而，`getMax`和`getMin` 函数会多次重复遍历。

验证 根节点val 是否比左子树所有的val大，比右子树所有的val小，也就是验证左子树所有val值的范围是否在[MIN_val, root→val), 右子树所有val的值是否在（root→val，MAX_val] 内；

```C++
bool isValidBST(TreeNode* root) {
    if(root == nullptr) return true;
    
    return inRange(root, LONG_MIN, LONG_MAX);
}   
bool inRange(TreeNode *root, ll l, ll r) {
    // 为了方便， 我们这里使用(l, r)
    if(root == nullptr) return true;
    if(root->val <= l || root->val >= r) return false;
    return inRange(root->left, l, root->val) && inRange(root->right, root->val, r); 
}
```



[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

#### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

#### [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)



#### [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

#### [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)      如何利用必须有的返回值来简化代码 |   插入节点一定可以为一个新添加的叶节点

二叉搜索树中使用bfs，如插入，查找等，往往是有方向的。 即去指定子树中寻找答案，不断缩小问题规模。



#### [669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)



#### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

#### [1382. 将二叉搜索树变平衡](https://leetcode-cn.com/problems/balance-a-binary-search-tree/)



[538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

> 本题很容易想到利用中序遍历序列为升序序列求新值，然后再一次中序遍历将新值赋给节点;

更进一步：
BST中序序列为升序，则逆序列为降序，即 `右→中→左`， 遍历时记录前一个访问的节点，cur→val  += pre→val， 
则一次逆中序遍历即可。



---

[450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

> 408中的做法是当要删除的节点即有左子树又有右子树时，用该节点直接前驱或后继代替该节点。
但在C++中具体实现的时候，不方便删除前驱/后继节点，  如下代码:

```C++
struct Node {
    int x;
    Node *next;
    Node(int x) : x(x) {}
    Node(int x, Node *next) : x(x), next(next) {}
};
int main() {
    Node *a = new Node(5, new Node(6));
    cout << a->next->x << endl;
    delete(a->next);
    cout << (a->next == nullptr) << endl;   // false
    cout << a->next->x << endl;
}
```

> 删除了`a→next`后，`a→next`成为野指针，而非`nullptr`， 要专门将其置为`nullptr`，否则会引发访问错误，然而置`nullptr`并不方便

**更方便代码实现的方法：**

![](https://secure2.wostatic.cn/static/x6D51wiuZv7mdavrurp13g/image.png)

---





### 自底向上遍历（后序遍历）

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

[235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)     **第一个满足条件的节点才是公共祖先且是最近公共祖先！**



#### [剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)
