`erase()`  时间复杂度O(n)

---

### 朴实无华 - 双指针

头尾对向双指针，实际上就是实现`reverse() `函数

[344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

```C++
void reverseString(vector<char>& s) {
    int l = 0, r = s.size() - 1;
    while(l < r) {
        swap(s[l++], s[r--]);
    }
}
```  
O(n), O(1)

[541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

```C++
string reverseStr(string s, int k) {
    for(int i = 0; i < s.size(); i += 2*k) {
        int l = i, r = min(int(s.size() - 1), i + k - 1);
        while(l < r) {
            swap(s[l++], s[r--]);
        }
    }
    return s;
}
```
O(n), O(1)


### 先整体后局部

翻转字符串一种思路：
* step1: 翻转整个字符串
* step2: 翻转指定子串

[151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/) 

```C++
string reverseWords(string s) {
    // 删除空格 O(n)
    int l = -1, r = 0;
    while(r < s.size() && s[r] == ' ') ++r;
    while(r < s.size()) {
        if(s[r] != ' ' || (s[r] == ' ' && s[r-1] != ' '))
            s[++l] = s[r];
        ++r;
    }
    if(s[l] == ' ') --l;
    s.erase(s.begin() + l + 1, s.end());

    // 翻转整个串 O(n)
    reverse(s.begin(), s.end());   // 双指针

    // 翻转每个单词 O(n)
    l = 0, r;
    while(l < s.size()) {
        r = l;
        while(r < s.size() && s[r] != ' ') ++r;
        reverse(s.begin() + l, s.begin() + r);
        l = r + 1;
    }
    return s;
}
```


### 空间O(1)方法

[剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

这题最简单的方法是新开辟一块空间建立新串，若果要求原字符串不能被改变，则只能这么做.

但若要求直接对原字符串修改，则:

首先，统计字符串中的空格数`count`，然后将原字符串的长度扩大到`origin_size + count * 2`,

接下来，**又是双指针**.

设两个指针l, r. 初始化r指向长度扩充后字符串的最后一个位置，l指向原字符串尾，

while(l >= 0)
* 若`l ！= ' '`， 则`string_r = string_l; --l, --r;`
* 若`l == ' '`， 则`string_r_r-1_r-2 = %20; --l, r -= 3;`

```C++
string replaceSpace(string s) {
    int count = 0;
    int l = s.size() - 1;
    for(char ch : s) {
        if(ch == ' ') ++count;
    }
    s.resize(s.size() + count*2);
    int r = s.size() - 1;
    while(l >= 0) {
        if(s[l] != ' ') {
            s[r] = s[l];
            --l;
            --r;
        } else {
            s[r] = '0';
            s[r-1] = '2';
            s[r-2] = '%';
            --l;
            r -= 3;
        }
    }
    return s;
}
```
时间复杂度：O(n)
原地修改，额外空间开销O(1)

[剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

* 将这个字符串翻转
* 将前n-k个字符组成的子串翻转
* 将后k个字符组成的子串翻转

```C++
string reverseLeftWords(string s, int k) {
    int n = s.size();
    reverse(s.begin(), s.end());
    reverse(s.begin(), s.end()-k);
    reverse(s.end()-k, s.end());
    return s;
}
 ```
 O(n), O(1)

**躲不开的KMP**

[KMP模板](https://github.com/mhvvv/Data_structures-and-algorithms/blob/main/经典数据结构/KMP.cpp)


[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

[459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)       彻底弄懂kmp 和这题Leetcode官方解法的证明 （to /ym kmp模板）
