## 单集合 距离不变快慢指针

[剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

[剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)
```C++
low = head, distance(fast, low) = k-1. 
```

## 单集合 变距离快慢指针: 滑动窗口(尺取)

> 思想： O(n)时间内获取所有连续子序列

[剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)


```C++
int lengthOfLongestSubstring(string s) {
    unordered_set<char> uset;
    int l = 0, r = 0;
    int result = 0;
    while(l <= r && r < s.size()) {
        if(uset.find(s[r]) == uset.end()) {
            uset.insert(s[r]);
            result = max(result, r-l+1);
            ++r;
        } else {
            uset.erase(s[l]);
            ++l;
        }
    }
    return result;
}

O(nlogn), logn为哈希开销
O(n)
```

## 多集合 

[剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

**归并排序**，方便逻辑操作，搞一个虚拟头节点.

```C++
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode *head = new ListNode(), *tail = head;
    while(l1 && l2) {
        if(l1->val < l2->val) {
            tail->next = l1;
            l1 = l1->next;
        } else {
            tail->next = l2;
            l2 = l2->next;
        }
        tail = tail->next;
    }
    if(l1) tail->next = l1;
    if(l2) tail->next = l2;
    l1 = head->next;
    delete head;
    return l1;
}

O(n), O(1)
```

[剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

哈希表？ 可以，下一位.

题目要求时间O(n), 空间O(1).

若A或B一个为空，直接返回nullptr.

la指向A的头，lb指向B的头，两者同时移动. 分情况：

* len(A) == len(B)，则la和lb同时到达第一个相交节点或同时为nullptr，直接返回即可.
* len(A) != len(B)，假设 len(A) < len(B)，相交部分长c，A总长a+c, B总长b+c，则la为nullptr时，lb位于B的第a+c个节点，这是令la = headB，两指针继续同时移动，这此必然lb先为nullptr，此时又lb移动了(b+c)-(a+c) = b-a步，la位于B的第b-a+1个节点。此时再令lb = headA，两者继续同时移动. 
    * 若A和B相交，则c > 0，移动a步后，lb位于a的第a+1个节点，即相交的第一个节点，la位于B的第b+1个节点，也是相交的第一个节点，即若相交，则第一次相遇时的节点为第一个公共节点.
    * 若A和B不相交，两指针必然不会指向同一个节点，且在总移动a+b-1步后la和lb同时为nullptr.
 
```C++
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    if(headA == nullptr || headB == nullptr) return nullptr;
    ListNode *la = headA, *lb = headB;
    while(true) {
        if(la == lb) return la;
        la = la->next;
        lb = lb->next;
        if(la == nullptr && lb == nullptr) return nullptr;
        if(la == nullptr) la = headB;
        if(lb == nullptr) lb = headA;
    }
    return nullptr; // 必然在while里返回，奇怪的lc
}

O(n), O(1)
```
