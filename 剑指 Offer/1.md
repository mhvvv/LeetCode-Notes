### 剑指 Offer 06. 从尾到头打印链表

[题目链接](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

逆序输出链表，reverse() 或 递归.

**reverse()**
```C++
  vector<int> printListFromTailToHead(ListNode* head) {
      vector<int> result;
      while(head != NULL) {
          result.push_back(head->val);
          head  = head->next;
      }
      reverse(result.begin(), result.end());
      return result;
  }
```
**递归**
```C++
vector<int> result;
void recursion(ListNode *head) {
    if(head == NULL) return;
    dfs(head->next);
    result.push_back(head->val);
}
vector<int> printListFromTailToHead(ListNode* head) {
    recursion(head);
    return result;
}
```

### 剑指 Offer 07. 重建二叉树

[题目链接](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

经典数据结构问题，期末考试必考题.

前序: [根，[左子树], [右子树]]
中序: [[左子树], 根，[右子树]]

建树就是不断建根结点， 当前树的根结点必然为当前树前序遍历序列的第一个值，然后在其中序序列中找出这个值.

对左右子树，前序序列和后序序列的结点个数相同，又因为在中序序列中，找出当前树的根后，就可以得出左右子树的结点个数，前序序列中左子树的结点必然排在右子树结点的前边，因此可以用结点数来划分左右子树的前序遍历序列.

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorder, inorder;
    unordered_map<int, int> umpVin;  // 将操作“查找val在vector中的位置”时间复杂度下降到O(1)
    void cursion(TreeNode *&root, int lp, int rp, int li, int ri) {
        if(lp > rp) return;
        root = new TreeNode(preorder[lp]);
        int k = umpVin[preorder[lp]]; 
        cursion(root->left, lp+1, lp+(k-li), li, k-1);
        cursion(root->right, rp-(ri-k)+1, rp, k+1, ri);
        
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size() == 0) return nullptr;
        this->preorder = preorder;
        this->inorder = inorder;
        for(int i=0; i<preorder.size(); ++i) 
            umpVin[inorder[i]] = i;
        TreeNode *root;
        cursion(root, 0, preorder.size()-1, 0, inorder.size()-1);
        return root;
    }
};
```

