(外部链接建议 新标签页打开)

### Day 1. (17th)
[1518. 换酒问题](https://leetcode-cn.com/problems/water-bottles/)

模拟， 水题

```C++
class Solution {
public:
    int numWaterBottles(int numBottles, int numExchange) {
        int result = numBottles;
        while(numBottles >= numExchange) {
            result += numBottles / numExchange;
            numBottles = numBottles / numExchange + numBottles % numExchange;
        }
        return result;
    }
};
```

时间复杂度约为 O(lognumE(numB)), 空间复杂度O(1)

### Day 2. (18th)
[419. 甲板上的战舰](https://leetcode-cn.com/problems/battleships-in-a-board/)

(这题不难, 但读懂题难. 出题人好像很怕你把题读懂的样子.)

水题, 一次遍历, 求战舰数即求”左上角“数.  
```C++
class Solution {
public:
    int countBattleships(vector<vector<char>>& board) {
        int result = 0;
        int m = board.size(), n = board[0].size();
        for(int i=0; i<m; ++i) {
            for(int j=0; j<n; ++j) {
                if(board[i][j] == '.') continue;
                if(j > 0 && board[i][j-1] == 'X') continue;
                else if(i > 0 && board[i-1][j] == 'X') continue;
                else ++result; 
            }
        }
        return result;
    }
};
```
### Day 3. (19th)

[997. 找到小镇的法官](https://leetcode-cn.com/problems/find-the-town-judge/)

水题，考察图论中的入度和出度，实际上不知道也没啥影响。

一次遍历统计入度 & 出度，一次遍历判断“法官”。

```C++
class Solution {
public:
    int findJudge(int n, vector<vector<int>>& trust) {
        vector<int> u(n+1, 0), v(n+1, 0);
        for(vector<int> i : trust) {
            ++u[i.front()];
            ++v[i.back()];
        }
        for(int i=1; i<=n; ++i) {
            if(u[i] == 0 && v[i] == n-1)
                return i;
        }
        return -1;
    }
};
```

### Day 4. (20th)

[475. 供暖器](https://leetcode-cn.com/problems/heaters/comments/)

#### 排序 + 二分查找答案

考虑**二分查找答案**，最小为 l = 0，最大不超过 r = max(max_houses, max_heaters).

1. 首先将houses和heaters从小到大排序;
2. 取 mid = l + (r-l)/2, h = 0, k = 0, 其中 mid 表示待判断是否可行的半径，h表示当前house，k表示当前heater;
3. 判断:
    * 若当前house处于当前header的覆盖范围内，即 heaters[k] - mid <= houses[h] <= heaters[k] + mid，则判断下一个houses，++h;
    * 若当前house太靠左，当前heater覆盖在当前半径mid下覆盖不到，即houses[h] < heaters[k] - mid，则需要更大的半径，l = mid + 1 (左边的heater都覆盖不到，右边的更别想了);
    * 若当前house太靠右，当前heater覆盖在当前半径mid下覆盖不到，即houses[h] > heaters[k] + mid，则尝试下一个heater，++k, 若已经是最后一个heater，则需要更大的半径，l = mid + 1.
4. 当前半径下若能全覆盖，则尝试更小的半径，r = mid

这里while(l < r), 缩小半径时 r = mid 而非 r = mid-1, 则最终r就是满足条件的最小半径.
```C++
class Solution {
public:
    int findRadius(vector<int>& houses, vector<int>& heaters) {
        sort(houses.begin(), houses.end());
        sort(heaters.begin(), heaters.end());
        int l = 0, r = max(houses.back(), heaters.back());
        int result = r;
        while(l < r) {
            int k = 0;
            int mid = l + (r-l)/2;
            int h = 0;
            while(h < houses.size()) {
                if(houses[h] > heaters[k] + mid) {
                    ++k;
                    if(k >= heaters.size()) {
                        l = mid+1;
                        break;
                    }   
                } else if(houses[h] < heaters[k] - mid) {
                    l = mid+1;
                    break;
                } else
                    ++h;
            }
            if(h == houses.size()) {
                result = min(result, mid);
                r = mid;
            }
        }
        return r;
    }
};
```
m 是数组houses 的长度，n 是数组heaters 的长度

时间复杂度： O(nlogn + mlogm + (n+m)logmax(max_houses, max_heaters))

空间复杂度： O(1)

![image](https://user-images.githubusercontent.com/49873642/146747023-15926673-7c4e-464b-ac18-5fa2be69e63e.png)

嗯... 不大行

#### 排序 + 二分查找heater

若想用最小半径覆盖一个房屋，要么用该房屋左边第一个供暖器，要么其右边第一个供暖器。

二分查找每个house左边第一个供暖器k(heater <= house), 则k+1就为其右边第一个供暖器; 

1. 求每个房屋据左右最近两个供暖器的最近距离;
2. 求以上所有最近距离的最大值。

```C++
class Solution {
public:
    int findRadius(vector<int>& houses, vector<int>& heaters) {
        sort(heaters.begin(), heaters.end());
        int result = 0;
        for(int h : houses) {
            if(heaters.front() > h) {   // 可能最左的供暖器也在其右边
                result = max(result, heaters.front() - h);
                continue;
            }
            int l = 0, r = heaters.size()-1, mid, theLeft;
            while(l <= r) {
                mid = l + (r-l)/2;
                if(heaters[mid] > h) r = mid - 1;
                else if(heaters[mid] <= h) {
                    theLeft = mid;
                    l = mid+1;
                }
            }
            if(theLeft == heaters.size()-1)
                result = max(result, h - heaters[theLeft]);
            else
                result = max(result, min(h - heaters[theLeft], heaters[theLeft+1] - h));
        }
        return result;
    }
};
```

时间复杂度： O(nlogn + mlogn) = O((n+m)logn)

空间复杂度： O(1)

#### 双指针

若houses和heaters都有序，可以证明：若离第i个house最近的heater为j，则离第i+1个house最近的heater必然 >= j.

因此只要先对houses和heaters排序，然后双指针一次遍历即可。

```C++
class Solution {
public:
    int findRadius(vector<int>& houses, vector<int>& heaters) {
        sort(heaters.begin(), heaters.end());
        sort(houses.begin(), houses.end());
        int result = 0;
        int i = 0, j = 0;
        while(i < houses.size()) {
            int dis = abs(heaters[j] - houses[i]);
            while(j+1 < heaters.size() && abs(heaters[j+1] - houses[i]) <= dis) {  // <= 
                ++j;
                dis = abs(heaters[j] - houses[i]);
            }
            if(dis != 0)
                return i;
            result = max(result, dis);
            ++i;
        }
        return result;
    }
};
```

需要注意，内层while判断使用 <=， 有个坑：可能有多个电热器在同一位置。

时间复杂度： O(nlogn + mlogn + m + n) 

空间复杂度： O(1)

时间主要花在排序上，若本就有序，则下降到线性时间复杂度。

