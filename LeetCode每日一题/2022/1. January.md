### Day 1. (7th)

[1614. 括号的最大嵌套深度](https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/)

题目保证是串是有效括号字符串，只需要用栈存一下，求栈的最大size就行了.

然后，栈的做法明白了后，发现并不要栈，直接遍历一遍就好了。

#### 栈
```C++
int maxDepth(string s) {
    int result = 0;
    stack<bool> st;
    for(char c : s) {
        if(c == '(') {
            st.push(false);
            result = max(result, st.size());
        } else if(c == ')') 
            st.pop();
    }
    return result;
}
```

时 / 空：O(n) / O(n)

#### 遍历
```C++
int maxDepth(string s) {
    int result = 0, t = 0;
    stack<bool> st;
    for(char c : s) {
        if(c == '(') {
            ++t;
            result = max(result, t);
        }
        else if(c == ')') --t;
    }
    return result;
}
```

时 / 空：O(n) / O(1)

### Day 2. (12th)

[334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)

可以先求出每个位置左边最小的数和每个位置右边最大的数，然后判断这个数是否比左边最小的数大，比右边最大的数小就可以了。

具体做法：
```C++
vector<int> left, right;
i: 0 -> end  left[i] = min(nums[0.. i-1])
i: end -> 0  right[i] = min(nums[i+1.. end])
i: 1 -> end-1    left[i] < i < right[i] ? 
```
时 / 空：O(n) / O(n)

> 你能实现时间复杂度为 O(n) ，空间复杂度为 O(1) 的解决方案吗？

时间复杂度要求O(n)，其实就是要求“指针”不能回退.

`贪心`策略： 我们要找 i < j < k， 使得 nums[i] < nums[j] < nums[k]. 为了容易找到j，我们希望nums[i]尽可能小，为了能够找到k，我们希望nums[j]尽可能小.

因为“指针”只能向前，对于“指针”当前指向的元素，做如下判断：

* 若nums[cur] > nums[j]，且 nums[j] > nums[i], 结束，返回 true;
* 若nums[cur] < nums[j]，则 根据贪心策略，更新 j = cur;
* 若nums[cur] < nums[i]，则 更新 i = cur，虽然这样会使得 i > j， 但并不影响 _存在i < j, 使得nums[i] < nums[j] 成立_，且可以给j向nums[j]更小的方向更新留下更大的空间.

```C++
bool increasingTriplet(vector<int>& nums) {
    int i = nums[0], j = INT_MAX, k = INT_MAX;   // i, j, k 即题目中的 nums[i], nums[j], nums[k].
    for(int num : nums) {
        if(num > j) return true;
        else if(num > i && num < j) j = num;
        else if(num < i) i = num;
    }
    return false;
}
```
时 / 空：O(n) / O(1)
    
