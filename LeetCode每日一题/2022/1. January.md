### Day 1. (7th)

[1614. 括号的最大嵌套深度](https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/)

题目保证是串是有效括号字符串，只需要用栈存一下，求栈的最大size就行了.

然后，栈的做法明白了后，发现并不要栈，直接遍历一遍就好了。

#### 栈
```C++
int maxDepth(string s) {
    int result = 0;
    stack<bool> st;
    for(char c : s) {
        if(c == '(') {
            st.push(false);
            result = max(result, st.size());
        } else if(c == ')') 
            st.pop();
    }
    return result;
}
```

时 / 空：O(n) / O(n)

#### 遍历
```C++
int maxDepth(string s) {
    int result = 0, t = 0;
    stack<bool> st;
    for(char c : s) {
        if(c == '(') {
            ++t;
            result = max(result, t);
        }
        else if(c == ')') --t;
    }
    return result;
}
```

时 / 空：O(n) / O(1)

### Day 2. (12th)

[334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)

可以先求出每个位置左边最小的数和每个位置右边最大的数，然后判断这个数是否比左边最小的数大，比右边最大的数小就可以了。

具体做法：
```C++
vector<int> left, right;
i: 0 -> end  left[i] = min(nums[0.. i-1])
i: end -> 0  right[i] = min(nums[i+1.. end])
i: 1 -> end-1    left[i] < i < right[i] ? 
```
时 / 空：O(n) / O(n)

> 你能实现时间复杂度为 O(n) ，空间复杂度为 O(1) 的解决方案吗？

时间复杂度要求O(n)，其实就是要求“指针”不能回退.

`贪心`策略： 我们要找 i < j < k， 使得 nums[i] < nums[j] < nums[k]. 为了容易找到j，我们希望nums[i]尽可能小，为了能够找到k，我们希望nums[j]尽可能小.

因为“指针”只能向前，对于“指针”当前指向的元素，做如下判断：

* 若nums[cur] > nums[j]，且 nums[j] > nums[i], 结束，返回 true;
* 若nums[cur] < nums[j]，则 根据贪心策略，更新 j = cur;
* 若nums[cur] < nums[i]，则 更新 i = cur，虽然这样会使得 i > j， 但并不影响 _存在i < j, 使得nums[i] < nums[j] 成立_，且可以给j向nums[j]更小的方向更新留下更大的空间.

```C++
bool increasingTriplet(vector<int>& nums) {
    int i = nums[0], j = INT_MAX, k = INT_MAX;   // i, j, k 即题目中的 nums[i], nums[j], nums[k].
    for(int num : nums) {
        if(num > j) return true;
        else if(num > i && num < j) j = num;
        else if(num < i) i = num;
    }
    return false;
}
```
时 / 空：O(n) / O(1)

### Day 3. (15th)

[1716. 计算力扣银行的钱](https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/)

等差数列求和

将每天存的钱看作一个等差数列

```C++
int totalMoney(int n) {
    int result = 0, a1 = 1;
    for(int i=1; i<=n/7; ++i) {
        result += 7 * (a1 + (a1 + 6)) / 2;
        ++a1;
    }
    for(int i=1; i<=n%7; ++i)
        result += (a1++);
    return result;
}
```

T / S: O(n) / O(1)

更进一步，将每周存的钱作为一个等差数列，第i周比第i-1周多存7块.

```C++
int totalMoney(int n) {
    int result = 0;
    int thisWeek = 7 * (1 + 7) / 2;
    result += n/7 * (thisWeek + (thisWeek + (n/7 - 1) * 7)) / 2;
    result += n%7 * ((n/7 + 1) + ((n/7 + 1) + (n%7 - 1))) / 2;
    return result;
}
```

T / S: O(1) / O(1)

### Day 4. (18th)

[539. 最小时间差](https://leetcode-cn.com/problems/minimum-time-difference/)

排序，最小间隔只可能是 相邻两个时间点的差 或 第一个和最后一个时间点的差.

另外，最多1440个不同时间点. 因此若出现 > 1440个时间点，则必有重复，直接返回0

```C++
int findMinDifference(vector<string>& timePoints) {
    if(timePoints.size() > 1440) return 0;
    vector<int> theTime(timePoints.size());
    for(int i=0; i<timePoints.size(); ++i)
        theTime[i] = (int(timePoints[i][0]-'0')*10 + int(timePoints[i][1]-'0')) * 60 + int(timePoints[i][3]-'0')*10 + int(timePoints[i][4] - '0'); 
    sort(theTime.begin(), theTime.end());
    int result = 1440;
    for(int i=1; i<theTime.size(); ++i)
        result = min(result, theTime[i] - theTime[i-1]); 
    result = min(result, theTime.front() + 1440 - theTime.back());
    return result;
}
```

O(min(n, 1440) * logmin(n, 1440))，O(1)

### Day 5. (22th)

[1332. 删除回文子序列](https://leetcode-cn.com/problems/remove-palindromic-subsequences/)

哈哈哈哈哈哈哈哈, nmd

```C++
int removePalindromeSub(string s) {
    int l = 0, r = s.size() - 1;
    while(l < r) {
        if(s[l] != s[r]) return 2;
        ++l;
        --r;
    }
    return 1;
}
```

O(n), O(1)
