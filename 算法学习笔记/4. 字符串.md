`erase()`  时间复杂度O(n)

---

### 朴实无华 - 双指针

头尾对向双指针，实际上就是实现`reverse() `函数

[344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

```C++
void reverseString(vector<char>& s) {
    int l = 0, r = s.size() - 1;
    while(l < r) {
        swap(s[l++], s[r--]);
    }
}
```  
O(n), O(1)

[541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

```C++
string reverseStr(string s, int k) {
    for(int i = 0; i < s.size(); i += 2*k) {
        int l = i, r = min(int(s.size() - 1), i + k - 1);
        while(l < r) {
            swap(s[l++], s[r--]);
        }
    }
    return s;
}
```
O(n), O(1)


### 先整体 后 局部
[151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/) 

**翻转字符串一种思路：**

1. 翻转整个字符串
2. 反转指定子串

```C++
string reverseWords(string s) {
    // 删除空格 O(n)
    int l = -1, r = 0;
    while(r < s.size() && s[r] == ' ') ++r;
    while(r < s.size()) {
        if(s[r] != ' ' || (s[r] == ' ' && s[r-1] != ' '))
            s[++l] = s[r];
        ++r;
    }
    if(s[l] == ' ') --l;
    s.erase(s.begin() + l + 1, s.end());

    // 翻转整个串 O(n)
    reverse(s.begin(), s.end());

    // 翻转每个单词 O(n)
    l = 0, r;
    while(l < s.size()) {
        r = l;
        while(r < s.size() && s[r] != ' ') ++r;
        reverse(s.begin() + l, s.begin() + r);
        l = r + 1;
    }
    return s;
}
```






**空间O(1)方法**



[剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

[剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)



**躲不开的KMP**

[KMP模板](https://github.com/mhvvv/Data_structures-and-algorithms/blob/main/经典数据结构/KMP.cpp)


[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

[459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)       彻底弄懂kmp 和这题Leetcode官方解法的证明 （to /ym kmp模板）
