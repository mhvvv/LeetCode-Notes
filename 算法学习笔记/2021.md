[LeetCode - 187.重复的DNA序列](https://leetcode-cn.com/problems/repeated-dna-sequences/)

#### s1. substr + 哈希

```C++
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        if(s.size() < 10) return {};
        unordered_map<string, int> ump;
        for(int i=0; i<s.size() - 9; ++i) 
            ++ump[s.substr(i, 10)];
        vector<string> result;
        for(auto u : ump) {
            if(u.second > 1)
                result.push_back(u.first);
        }
        return result;
    }
};
```
时间复杂度O(10n)，substr时间开销大.

#### s2. 滑动窗口 + 字符串编码 + 哈希

四个字母，可以分别编码0-3，使用4进制数给字符串编码，可以解决判断子串是否出现使用substr时间开销大的问题，配合滑动窗口可以将时间复杂度优化到O(1).

```C++
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        if(s.size() < 10) return {};

        vector<int> nums(s.size());
        for(int i=0; i<s.size(); ++i) {
            switch (s[i]) {
                case 'A':
                    nums[i] = 0;
                    break;
                case 'C':
                    nums[i] = 1;
                    break;
                case 'G':
                    nums[i] = 2;
                    break;
                default:
                    nums[i] = 3;
            }
        }

        unordered_set<string> result;
        unordered_set<int> st;
        int encode = 0;
        int k = pow(4, 9);
        for(int i=0; i<10; ++i) 
            encode += nums[i] * pow(4, 9-i);
        st.insert(encode);
        for(int i=1; i<nums.size() - 9; ++i) {
            encode -= nums[i-1] * k;
            encode *= 4;
            encode += nums[i+9];
            if(st.find(encode) != st.end())
                result.insert(s.substr(i, 10));
            else
                st.insert(encode);
        }

        return vector<string>(result.begin(), result.end());
    }
};
```
时间复杂度：O(n)  这里没有计算substr取符合要求的子串的开销.  

但这种编码有个问题，当要编码的字符串很长，或进制很高时，可能出现数值越界，mod运算又可能“碰撞”，取多个mod仍(多个编码，相同mod P)可能碰撞，总的来说不是确定性算法.

---

[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/comments/)

求每个柱子左边最高的柱子的高度left[i]及右边最高的柱子高度right[i]，则此根柱子能接的雨水量为 min(left[i], right[i]) - height[i].  

计算最高高度时包括自身高度，上述计算结果一定 >= 0. 即最高高度为自己时接不了雨水.

```C++
int trap(vector<int>& height) {
    int n = height.size();
    vector<int> left(n), right(n);  // left[i] 表示i左边最大的值, right表示右边
    int highest = 0;
    for(int i=0; i<n; ++i) {
        highest = max(height[i], highest);
        left[i] = highest;
    }
    highest = 0;
    for(int i=n-1; i>=0; --i) {
        highest = max(height[i], highest);
        right[i] = highest;
    }
    int result = 0;
    for(int i=1; i<=n-2; ++i) {
        result += min(left[i], right[i]) - height[i];
    }
    return result;
}
```
时间复杂度: O(n)  

空间复杂度O(n)
