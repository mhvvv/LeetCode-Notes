## 1. dp思路

核心思想：拆分问题，找子结构

step：
1. 状态
2. 状态转移方程
3. 求解方向 (按照何种顺序“填表格”) & 初始状态 

动态规划的题目分为三3大类:  
* 最优解类，典型问题是背包问题;       
* 计数类( 方案数，路线数） 
* 判断是否可以类 （子集和问题）

**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**

**考虑dp数组是否可以降维，即是否可以使用滚动数组**

## 2. 基础题目

[509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

[746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

```C++
*** dp:
int uniquePaths(int m, int n) {
    // 1. 状态:  dp[i][j] 从起点到(i,j)的路径数 , 考虑滚动数组
    vector<int> dp(n, 1);   // 3. 初始状态: 第一行的位置只有一种到达方式
    for(int i = 1; i < m; ++i) {
        for(int j = 1; j < n; ++j)  // dp(i, 0) = dp(i-1, 0)
            dp[j] = dp[j-1] + dp[j];   // 2. 状态转移方程: ↓ →
    }
    return dp[n-1];
}
O(mn), O(n)

*** m_dfs:
class Solution {
public:
    int uniquePaths(int m, int n) {
        this->m = m;
        this->n = n;
        vis.resize(m, vector<int>(n, -1));
        
        return m_dfs(0, 0);
    }
    int m_dfs(int x, int y) {
        if(x >= m || y >= n) return 0;
        if(vis[x][y] != -1) return vis[x][y];
        if(x == m-1 && y == n-1) return 1;

        return vis[x][y] = m_dfs(x+1, y) + m_dfs(x, y+1); 
    }
private:
    int m, n;
    vector<vector<int>> vis;
};
O(mn), O(mn)
```

[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

```C++
int uniquePathsWithObstacles(vector<vector<int>>& obs)  {
    int m = obs.size(), n = obs[0].size();
    vector<int> dp(n, 0);
    for(int i = 0; i < n && obs[0][i] != 1; ++i)
        dp[i] = 1;
    for(int i = 1; i < m; ++i) {
        dp[0] = obs[i][0] == 1 ? 0 : dp[0];
        for(int j = 1; j < n; ++j) 
            dp[j] = obs[i][j] == 1 ? 0 : dp[j] + dp[j-1];
    }    
    return dp[n-1];
}

O(mn), O(n)
```

[343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

1. 状态: `dp[i]`表示整数i的最大拆分
2. 状态转移方程 `dp[i] = max(dp[i], max(dp[i-j], i-j) * max(dp[j], j))  j < i`
   > i 可以拆分为 i-j 和 j (j < i), 然后递归拆分 i-j 和 j 即可。  那么对于拆分出的 i-j 和 j, 其贡献最大拆分为 `max(dp[i-j], i-j) * max(dp[j], j)`
3. 初始状态: `dp[1] = 1`

```C++
int integerBreak(int n) {
    vector<int> dp(n+1, 0);
    dp[0] = 0;
    dp[1] = 1;
    for(int i = 2; i <= n; ++i) {
        for(int j = 1; j < i; ++j)
            dp[i] = max(dp[i], max(i-j, dp[i-j]) * max(j, dp[j]));
    }   
    return dp[n];
}

O(n^2), O(n)
```


[96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

先明确，序列{1, 2, 3}和序列{7, 8, 9}能构成的二叉搜索树数是相同的. 即构成二叉搜索树的数目只与序列长度有关，与序列里的具体元素值无关.

求长度为n的序列所对应数目，只要求序列中各个个元素作为结点所构成的二叉搜索树数目之和即可.

划分子问题： 对于序列{1, 2, 3, 4, 5}, `以3为根的二叉搜索树数目 = 左子树序列{1, 2}构成的二叉搜索树数目 * 右子树序列{4, 5}构成的二叉搜索树数目`.

1. 状态： dp[i]表示长度为n的序列能构成的二叉搜索树数目
2. 状态转移方程：dp[i] = sum(dp[j] * dp[i - j -1])  0 <= j < i
3. 初始状态：dp[0] = dp[1] = 1.   特别注意dp[0] = 1
```C++
int numTrees(int n) {
    vector<int> dp(n+1, 0);
    dp[0] = dp[1] = 1;
    for(int i = 2; i <= n; ++i) {
        for(int j = 0; j < i; ++j)
            dp[i] += (dp[j] * dp[i-j-1]);
    }
    return dp[n];
}
```

O(n^2), O(n)

### 背包问题

![image](https://user-images.githubusercontent.com/49873642/149645002-52be6f98-2ed6-4f44-a43e-4199387273fd.png)

装满背包方案数问题，特别注意是否需要初始化状态`dp[0] = 1 `， 因为装满容量为0的背包有一种方式，那就是什么都不装。这是递推的基础。

最大价值：max，  min

方案数：+=

背包内外层循环是否可以交换?  

#### 01背包

[416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)  （二维记忆化)

[1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

[494. 目标和](https://leetcode-cn.com/problems/target-sum/)

[474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)



#### 完全背包 

二维数组实现完全背包?

[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

[139. 单词拆分](https://leetcode-cn.com/problems/word-break/)



[面试题 08.11. 硬币](https://leetcode-cn.com/problems/coin-lcci/)  ？？？？

```C++
这似乎是个**完全背包**问题， 但此时我已经忘记完全背包的套路了；  但，我很强，我不需要套路. 嗯，不需要

1. 状态:
dp[i][j]: 用前i种硬币 装满 j 有几种装法

2. 状态转移方程
dp[i][j] = dp[i-1][j] + dp[i-1][j-k*coins[i]], 其中 k*coins[i] <= j

3. 求解方向
↓ ↘   (考虑一维滚动数组)

4. 初始状态
dp[~][0] = 1
dp[0][!0] = 0

-> 时间优化：
dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i-1]] + dp[i-1][j-2*coins[i-1]] + 
                        dp[i-1][j-3*coins[i-1]] + ··· + dp[i-1][j-k*coins[i-1]]
dp[i][j-coins[i]] = dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i-1]] + 
                        dp[i-1][j-3*coins[i-1]] + ··· + dp[i-1][j-k*coins[i-1]]

∴  dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]]    j >= coins[i]

-> 空间优化, 滚动数组
    dp[j] = (dp[j] + dp[j-coins[i]])     j 要从大倒小

```

### 打家劫舍

[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

[337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)      树形dp入门



### 股票问题

[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

[714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)



### 子序列系列

[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

[674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

[718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

[1035. 不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/)

[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

[392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

> Summary:

子序列默认不连续，  `dp[i]`常表示截止i位置
子数组默认连续， `dp[i]`常表示以nums[i]为结尾

### “删”?

[392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

[115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

[583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

---

[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)      

> 计数问题；
dp数组用于记录状态而非记数，    且 体现出遍历顺序的重要性        遍历顺序依赖于状态转移方程

---

[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)             dp最优质， 体现遍历顺序

